import request from 'supertest';
import app from '../../index';
import { DatabaseService } from '../../services/database';
import { SecurityTestResult } from '../../types/performance';

export class VulnerabilityScanner {
    private db: DatabaseService;
    private testResults: SecurityTestResult[] = [];

    constructor() {
        this.db = DatabaseService.getInstance();
    }

    async runComprehensiveScan(): Promise<SecurityTestResult[]> {
        console.log('üîí Starting comprehensive security vulnerability scan...');

        this.testResults = [];

        // Run all security test categories
        await this.scanAuthentication();
        await this.scanAuthorization();
        await this.scanInputValidation();
        await this.scanDataExposure();
        await this.scanSessionSecurity();
        await this.scanCSRFProtection();
        await this.scanXSSProtection();
        await this.scanSQLInjection();
        await this.scanFileUploadSecurity();
        await this.scanAPISecurityHeaders();
        await this.scanRateLimiting();
        await this.scanCryptographicSecurity();

        // Generate summary
        this.generateSecuritySummary();

        return this.testResults;
    }

    private async scanAuthentication(): Promise<void> {
        console.log('üîê Scanning authentication vulnerabilities...');

        // Test weak password acceptance
        try {
            const weakPasswords = ['123456', 'password', 'admin', 'qwerty'];

            for (const weakPassword of weakPasswords) {
                const response = await request(app)
                    .post('/api/auth/register')
                    .send({
                        email: `weak-test-${Date.now()}@example.com`,
                        password: weakPassword,
                        firstName: 'Test',
                        lastName: 'User'
                    });

                if (response.status === 201) {
                    this.addResult({
                        test_name: 'Weak Password Acceptance',
                        category: 'authentication',
                        severity: 'high',
                        passed: false,
                        description: `System accepts weak password: ${weakPassword}`,
                        remediation: 'Implement strong password requirements with minimum length, complexity rules'
                    });
                }
            }

            this.addResult({
                test_name: 'Password Strength Validation',
                category: 'authentication',
                severity: 'medium',
                passed: true,
                description: 'System properly rejects weak passwords'
            });

        } catch (error) {
            this.addResult({
                test_name: 'Authentication Security Test',
                category: 'authentication',
                severity: 'medium',
                passed: false,
                description: 'Failed to test authentication security',
                details: error.message
            });
        }

        // Test brute force protection
        try {
            const attempts = [];
            for (let i = 0; i < 10; i++) {
                attempts.push(
                    request(app)
                        .post('/api/auth/login')
                        .send({
                            email: 'brute-force-test@example.com',
                            password: 'wrongpassword'
                        })
                );
            }

            const responses = await Promise.all(attempts);
            const rateLimitedCount = responses.filter(r => r.status === 429).length;

            if (rateLimitedCount === 0) {
                this.addResult({
                    test_name: 'Brute Force Protection',
                    category: 'authentication',
                    severity: 'high',
                    passed: false,
                    description: 'No rate limiting detected for failed login attempts',
                    remediation: 'Implement rate limiting and account lockout mechanisms'
                });
            } else {
                this.addResult({
                    test_name: 'Brute Force Protection',
                    category: 'authentication',
                    severity: 'high',
                    passed: true,
                    description: 'Rate limiting active for failed login attempts'
                });
            }

        } catch (error) {
            this.addResult({
                test_name: 'Brute Force Protection Test',
                category: 'authentication',
                severity: 'high',
                passed: false,
                description: 'Failed to test brute force protection',
                details: error.message
            });
        }
    }

    private async scanAuthorization(): Promise<void> {
        console.log('üõ°Ô∏è Scanning authorization vulnerabilities...');

        // Test for privilege escalation
        try {
            // Create test user
            const userResponse = await request(app)
                .post('/api/auth/register')
                .send({
                    email: `authz-test-${Date.now()}@example.com`,
                    password: 'AuthzTest123!',
                    firstName: 'Authz',
                    lastName: 'Test'
                });

            if (userResponse.status === 201) {
                const token = userResponse.body.data.access_token;

                // Try to access admin endpoints
                const adminEndpoints = [
                    '/api/admin/users',
                    '/api/admin/system',
                    '/api/admin/audit'
                ];

                let adminAccessCount = 0;
                for (const endpoint of adminEndpoints) {
                    const response = await request(app)
                        .get(endpoint)
                        .set('Authorization', `Bearer ${token}`);

                    if (response.status === 200) {
                        adminAccessCount++;
                    }
                }

                if (adminAccessCount > 0) {
                    this.addResult({
                        test_name: 'Privilege Escalation',
                        category: 'authorization',
                        severity: 'critical',
                        passed: false,
                        description: `Regular user can access ${adminAccessCount} admin endpoints`,
                        remediation: 'Implement proper role-based access control (RBAC)'
                    });
                } else {
                    this.addResult({
                        test_name: 'Privilege Escalation',
                        category: 'authorization',
                        severity: 'critical',
                        passed: true,
                        description: 'Admin endpoints properly protected from regular users'
                    });
                }
            }

        } catch (error) {
            this.addResult({
                test_name: 'Authorization Test',
                category: 'authorization',
                severity: 'high',
                passed: false,
                description: 'Failed to test authorization controls',
                details: error.message
            });
        }
    }

    private async scanInputValidation(): Promise<void> {
        console.log('üîç Scanning input validation vulnerabilities...');

        // Test for SQL injection
        const sqlPayloads = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "'; INSERT INTO users (email) VALUES ('hacker@evil.com'); --",
            "' UNION SELECT * FROM auth.users --"
        ];

        for (const payload of sqlPayloads) {
            try {
                const response = await request(app)
                    .post('/api/auth/login')
                    .send({
                        email: payload,
                        password: 'anypassword'
                    });

                // If we get a 500 error, it might indicate SQL injection vulnerability
                if (response.status === 500) {
                    this.addResult({
                        test_name: 'SQL Injection Vulnerability',
                        category: 'input_validation',
                        severity: 'critical',
                        passed: false,
                        description: `Potential SQL injection with payload: ${payload}`,
                        remediation: 'Use parameterized queries and input sanitization'
                    });
                }

            } catch (error) {
                // Network errors are expected for malformed requests
            }
        }

        // Test for XSS
        const xssPayloads = [
            '<script>alert("XSS")</script>',
            '<img src="x" onerror="alert(\'XSS\')" />',
            'javascript:alert("XSS")',
            '<svg onload="alert(\'XSS\')" />'
        ];

        // Test XSS in content creation (if endpoint exists)
        try {
            const userResponse = await request(app)
                .post('/api/auth/register')
                .send({
                    email: `xss-test-${Date.now()}@example.com`,
                    password: 'XSSTest123!',
                    firstName: 'XSS',
                    lastName: 'Test'
                });

            if (userResponse.status === 201) {
                const token = userResponse.body.data.access_token;

                for (const payload of xssPayloads) {
                    const response = await request(app)
                        .post('/api/content')
                        .set('Authorization', `Bearer ${token}`)
                        .send({
                            title: payload,
                            content: payload,
                            excerpt: payload
                        });

                    if (response.status === 201) {
                        // Check if XSS payload was sanitized
                        const contentId = response.body.data.id;
                        const getResponse = await request(app)
                            .get(`/api/content/${contentId}`)
                            .set('Authorization', `Bearer ${token}`);

                        if (getResponse.status === 200) {
                            const content = getResponse.body.data;
                            if (content.title.includes('<script>') || content.content.includes('<script>')) {
                                this.addResult({
                                    test_name: 'XSS Vulnerability',
                                    category: 'input_validation',
                                    severity: 'high',
                                    passed: false,
                                    description: `XSS payload not sanitized: ${payload}`,
                                    remediation: 'Implement proper input sanitization and output encoding'
                                });
                            }
                        }
                    }
                }
            }

        } catch (error) {
            // Content endpoint might not exist
        }

        this.addResult({
            test_name: 'Input Validation',
            category: 'input_validation',
            severity: 'high',
            passed: true,
            description: 'Input validation appears to be working correctly'
        });
    }

    private async scanDataExposure(): Promise<void> {
        console.log('üìä Scanning data exposure vulnerabilities...');

        try {
            // Test for sensitive data in API responses
            const userResponse = await request(app)
                .post('/api/auth/register')
                .send({
                    email: `exposure-test-${Date.now()}@example.com`,
                    password: 'ExposureTest123!',
                    firstName: 'Exposure',
                    lastName: 'Test'
                });

            if (userResponse.status === 201) {
                const token = userResponse.body.data.access_token;

                const profileResponse = await request(app)
                    .get('/api/auth/me')
                    .set('Authorization', `Bearer ${token}`);

                if (profileResponse.status === 200) {
                    const userData = profileResponse.body.data;

                    // Check for exposed sensitive fields
                    const sensitiveFields = ['password', 'encrypted_password', 'password_hash', 'secret_key'];
                    const exposedFields = sensitiveFields.filter(field => userData.hasOwnProperty(field));

                    if (exposedFields.length > 0) {
                        this.addResult({
                            test_name: 'Sensitive Data Exposure',
                            category: 'data_exposure',
                            severity: 'high',
                            passed: false,
                            description: `Sensitive fields exposed in API response: ${exposedFields.join(', ')}`,
                            remediation: 'Remove sensitive fields from API responses'
                        });
                    } else {
                        this.addResult({
                            test_name: 'Sensitive Data Exposure',
                            category: 'data_exposure',
                            severity: 'high',
                            passed: true,
                            description: 'No sensitive data exposed in user profile API'
                        });
                    }
                }
            }

        } catch (error) {
            this.addResult({
                test_name: 'Data Exposure Test',
                category: 'data_exposure',
                severity: 'medium',
                passed: false,
                description: 'Failed to test data exposure',
                details: error.message
            });
        }
    }

    private async scanSessionSecurity(): Promise<void> {
        console.log('üç™ Scanning session security vulnerabilities...');

        try {
            const response = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'session-test@example.com',
                    password: 'SessionTest123!'
                });

            if (response.status === 200) {
                const cookies = response.headers['set-cookie'];

                if (cookies) {
                    let hasSecureFlag = false;
                    let hasHttpOnlyFlag = false;
                    let hasSameSiteFlag = false;

                    cookies.forEach(cookie => {
                        if (cookie.includes('Secure')) hasSecureFlag = true;
                        if (cookie.includes('HttpOnly')) hasHttpOnlyFlag = true;
                        if (cookie.includes('SameSite')) hasSameSiteFlag = true;
                    });

                    if (!hasSecureFlag) {
                        this.addResult({
                            test_name: 'Session Cookie Security - Secure Flag',
                            category: 'session',
                            severity: 'medium',
                            passed: false,
                            description: 'Session cookies missing Secure flag',
                            remediation: 'Add Secure flag to session cookies'
                        });
                    }

                    if (!hasHttpOnlyFlag) {
                        this.addResult({
                            test_name: 'Session Cookie Security - HttpOnly Flag',
                            category: 'session',
                            severity: 'medium',
                            passed: false,
                            description: 'Session cookies missing HttpOnly flag',
                            remediation: 'Add HttpOnly flag to session cookies'
                        });
                    }

                    if (!hasSameSiteFlag) {
                        this.addResult({
                            test_name: 'Session Cookie Security - SameSite Flag',
                            category: 'session',
                            severity: 'low',
                            passed: false,
                            description: 'Session cookies missing SameSite flag',
                            remediation: 'Add SameSite flag to session cookies'
                        });
                    }

                    if (hasSecureFlag && hasHttpOnlyFlag && hasSameSiteFlag) {
                        this.addResult({
                            test_name: 'Session Cookie Security',
                            category: 'session',
                            severity: 'medium',
                            passed: true,
                            description: 'Session cookies have proper security flags'
                        });
                    }
                }
            }

        } catch (error) {
            this.addResult({
                test_name: 'Session Security Test',
                category: 'session',
                severity: 'medium',
                passed: false,
                description: 'Failed to test session security',
                details: error.message
            });
        }
    }

    private async scanCSRFProtection(): Promise<void> {
        console.log('üõ°Ô∏è Scanning CSRF protection...');

        try {
            // Test CSRF protection on state-changing operations
            const userResponse = await request(app)
                .post('/api/auth/register')
                .send({
                    email: `csrf-test-${Date.now()}@example.com`,
                    password: 'CSRFTest123!',
                    firstName: 'CSRF',
                    lastName: 'Test'
                });

            if (userResponse.status === 201) {
                const token = userResponse.body.data.access_token;

                // Try to make a state-changing request with suspicious origin
                const response = await request(app)
                    .post('/api/content')
                    .set('Authorization', `Bearer ${token}`)
                    .set('Origin', 'https://evil.com')
                    .send({
                        title: 'CSRF Test Content',
                        content: 'Testing CSRF protection'
                    });

                if (response.status === 201) {
                    this.addResult({
                        test_name: 'CSRF Protection',
                        category: 'csrf',
                        severity: 'medium',
                        passed: false,
                        description: 'CSRF protection not implemented for state-changing operations',
                        remediation: 'Implement CSRF tokens and origin validation'
                    });
                } else if (response.status === 403 || response.status === 400) {
                    this.addResult({
                        test_name: 'CSRF Protection',
                        category: 'csrf',
                        severity: 'medium',
                        passed: true,
                        description: 'CSRF protection active for state-changing operations'
                    });
                }
            }

        } catch (error) {
            this.addResult({
                test_name: 'CSRF Protection Test',
                category: 'csrf',
                severity: 'medium',
                passed: false,
                description: 'Failed to test CSRF protection',
                details: error.message
            });
        }
    }

    private async scanXSSProtection(): Promise<void> {
        console.log('üö´ Scanning XSS protection...');

        // This is covered in input validation, but we can add specific XSS header checks
        try {
            const response = await request(app).get('/api/status');

            const xssProtection = response.headers['x-xss-protection'];
            const contentTypeOptions = response.headers['x-content-type-options'];

            if (!xssProtection || xssProtection !== '1; mode=block') {
                this.addResult({
                    test_name: 'XSS Protection Header',
                    category: 'xss',
                    severity: 'low',
                    passed: false,
                    description: 'Missing or incorrect X-XSS-Protection header',
                    remediation: 'Add X-XSS-Protection: 1; mode=block header'
                });
            }

            if (!contentTypeOptions || contentTypeOptions !== 'nosniff') {
                this.addResult({
                    test_name: 'Content Type Options Header',
                    category: 'xss',
                    severity: 'low',
                    passed: false,
                    description: 'Missing X-Content-Type-Options: nosniff header',
                    remediation: 'Add X-Content-Type-Options: nosniff header'
                });
            }

            if (xssProtection === '1; mode=block' && contentTypeOptions === 'nosniff') {
                this.addResult({
                    test_name: 'XSS Protection Headers',
                    category: 'xss',
                    severity: 'low',
                    passed: true,
                    description: 'Proper XSS protection headers configured'
                });
            }

        } catch (error) {
            this.addResult({
                test_name: 'XSS Protection Test',
                category: 'xss',
                severity: 'low',
                passed: false,
                description: 'Failed to test XSS protection headers',
                details: error.message
            });
        }
    }

    private async scanSQLInjection(): Promise<void> {
        console.log('üíâ Scanning SQL injection vulnerabilities...');

        // This is partially covered in input validation, but we can add database-specific tests
        try {
            const sqlPayloads = [
                "1' OR '1'='1",
                "1'; DROP TABLE users; --",
                "1' UNION SELECT * FROM auth.users --"
            ];

            for (const payload of sqlPayloads) {
                // Test in search endpoint if it exists
                const response = await request(app)
                    .get('/api/content/search')
                    .query({ q: payload });

                // A 500 error might indicate SQL injection vulnerability
                if (response.status === 500) {
                    this.addResult({
                        test_name: 'SQL Injection in Search',
                        category: 'sql_injection',
                        severity: 'critical',
                        passed: false,
                        description: `Potential SQL injection in search with payload: ${payload}`,
                        remediation: 'Use parameterized queries for all database operations'
                    });
                }
            }

            this.addResult({
                test_name: 'SQL Injection Protection',
                category: 'sql_injection',
                severity: 'critical',
                passed: true,
                description: 'No SQL injection vulnerabilities detected'
            });

        } catch (error) {
            this.addResult({
                test_name: 'SQL Injection Test',
                category: 'sql_injection',
                severity: 'critical',
                passed: false,
                description: 'Failed to test SQL injection protection',
                details: error.message
            });
        }
    }

    private async scanFileUploadSecurity(): Promise<void> {
        console.log('üìÅ Scanning file upload security...');

        try {
            // Test malicious file upload
            const maliciousFiles = [
                { name: 'malware.exe', content: 'MZ\x90\x00\x03', type: 'application/octet-stream' },
                { name: 'script.php', content: '<?php system($_GET["cmd"]); ?>', type: 'application/x-php' },
                { name: '../../../etc/passwd', content: 'root:x:0:0:root:/root:/bin/bash', type: 'text/plain' }
            ];

            const userResponse = await request(app)
                .post('/api/auth/register')
                .send({
                    email: `upload-test-${Date.now()}@example.com`,
                    password: 'UploadTest123!',
                    firstName: 'Upload',
                    lastName: 'Test'
                });

            if (userResponse.status === 201) {
                const token = userResponse.body.data.access_token;

                for (const file of maliciousFiles) {
                    const response = await request(app)
                        .post('/api/media/upload')
                        .set('Authorization', `Bearer ${token}`)
                        .attach('file', Buffer.from(file.content), file.name);

                    if (response.status === 201) {
                        this.addResult({
                            test_name: 'Malicious File Upload',
                            category: 'input_validation',
                            severity: 'high',
                            passed: false,
                            description: `Malicious file upload accepted: ${file.name}`,
                            remediation: 'Implement file type validation and content scanning'
                        });
                    }
                }

                this.addResult({
                    test_name: 'File Upload Security',
                    category: 'input_validation',
                    severity: 'high',
                    passed: true,
                    description: 'File upload security controls working correctly'
                });
            }

        } catch (error) {
            // Upload endpoint might not exist
            this.addResult({
                test_name: 'File Upload Security Test',
                category: 'input_validation',
                severity: 'medium',
                passed: true,
                description: 'File upload endpoint not available or properly secured'
            });
        }
    }

    private async scanAPISecurityHeaders(): Promise<void> {
        console.log('üîí Scanning API security headers...');

        try {
            const response = await request(app).get('/api/status');

            const requiredHeaders = {
                'x-frame-options': ['DENY', 'SAMEORIGIN'],
                'x-content-type-options': ['nosniff'],
                'strict-transport-security': null, // Just check if present
                'content-security-policy': null
            };

            let missingHeaders = [];
            let incorrectHeaders = [];

            Object.entries(requiredHeaders).forEach(([header, expectedValues]) => {
                const actualValue = response.headers[header];

                if (!actualValue) {
                    missingHeaders.push(header);
                } else if (expectedValues && !expectedValues.includes(actualValue)) {
                    incorrectHeaders.push(`${header}: ${actualValue}`);
                }
            });

            if (missingHeaders.length > 0) {
                this.addResult({
                    test_name: 'Missing Security Headers',
                    category: 'data_exposure',
                    severity: 'medium',
                    passed: false,
                    description: `Missing security headers: ${missingHeaders.join(', ')}`,
                    remediation: 'Add missing security headers to API responses'
                });
            }

            if (incorrectHeaders.length > 0) {
                this.addResult({
                    test_name: 'Incorrect Security Headers',
                    category: 'data_exposure',
                    severity: 'low',
                    passed: false,
                    description: `Incorrect security headers: ${incorrectHeaders.join(', ')}`,
                    remediation: 'Fix security header values'
                });
            }

            if (missingHeaders.length === 0 && incorrectHeaders.length === 0) {
                this.addResult({
                    test_name: 'API Security Headers',
                    category: 'data_exposure',
                    severity: 'medium',
                    passed: true,
                    description: 'All required security headers present and correct'
                });
            }

        } catch (error) {
            this.addResult({
                test_name: 'Security Headers Test',
                category: 'data_exposure',
                severity: 'medium',
                passed: false,
                description: 'Failed to test security headers',
                details: error.message
            });
        }
    }

    private async scanRateLimiting(): Promise<void> {
        console.log('‚è±Ô∏è Scanning rate limiting...');

        try {
            const requests = [];
            const maxRequests = 50;

            // Make rapid requests to test rate limiting
            for (let i = 0; i < maxRequests; i++) {
                requests.push(request(app).get('/api/status'));
            }

            const responses = await Promise.all(requests);
            const rateLimitedCount = responses.filter(r => r.status === 429).length;

            if (rateLimitedCount === 0) {
                this.addResult({
                    test_name: 'Rate Limiting',
                    category: 'authentication',
                    severity: 'medium',
                    passed: false,
                    description: 'No rate limiting detected for API endpoints',
                    remediation: 'Implement rate limiting to prevent abuse'
                });
            } else {
                this.addResult({
                    test_name: 'Rate Limiting',
                    category: 'authentication',
                    severity: 'medium',
                    passed: true,
                    description: `Rate limiting active - ${rateLimitedCount} requests limited`
                });
            }

        } catch (error) {
            this.addResult({
                test_name: 'Rate Limiting Test',
                category: 'authentication',
                severity: 'medium',
                passed: false,
                description: 'Failed to test rate limiting',
                details: error.message
            });
        }
    }

    private async scanCryptographicSecurity(): Promise<void> {
        console.log('üîê Scanning cryptographic security...');

        try {
            // Check password hashing
            const testUser = await this.db.query(`
        SELECT encrypted_password FROM auth.users 
        WHERE email LIKE '%test%' 
        LIMIT 1
      `);

            if (testUser.rows.length > 0) {
                const hashedPassword = testUser.rows[0].encrypted_password;

                // Check if using bcrypt (should start with $2a$, $2b$, or $2y$)
                if (!hashedPassword.match(/^\$2[aby]\$\d+\$/)) {
                    this.addResult({
                        test_name: 'Password Hashing Algorithm',
                        category: 'authentication',
                        severity: 'high',
                        passed: false,
                        description: 'Weak password hashing algorithm detected',
                        remediation: 'Use bcrypt or similar strong hashing algorithm'
                    });
                } else {
                    this.addResult({
                        test_name: 'Password Hashing Algorithm',
                        category: 'authentication',
                        severity: 'high',
                        passed: true,
                        description: 'Strong password hashing algorithm in use'
                    });
                }
            }

        } catch (error) {
            this.addResult({
                test_name: 'Cryptographic Security Test',
                category: 'authentication',
                severity: 'high',
                passed: false,
                description: 'Failed to test cryptographic security',
                details: error.message
            });
        }
    }

    private addResult(result: Omit<SecurityTestResult, 'passed'> & { passed: boolean }): void {
        this.testResults.push(result);
    }

    private generateSecuritySummary(): void {
        const totalTests = this.testResults.length;
        const passedTests = this.testResults.filter(r => r.passed).length;
        const failedTests = totalTests - passedTests;

        const criticalIssues = this.testResults.filter(r => !r.passed && r.severity === 'critical').length;
        const highIssues = this.testResults.filter(r => !r.passed && r.severity === 'high').length;
        const mediumIssues = this.testResults.filter(r => !r.passed && r.severity === 'medium').length;
        const lowIssues = this.testResults.filter(r => !r.passed && r.severity === 'low').length;

        console.log('\nüîí Security Scan Summary:');
        console.log(`   Total Tests: ${totalTests}`);
        console.log(`   Passed: ${passedTests}`);
        console.log(`   Failed: ${failedTests}`);
        console.log(`   Critical Issues: ${criticalIssues}`);
        console.log(`   High Issues: ${highIssues}`);
        console.log(`   Medium Issues: ${mediumIssues}`);
        console.log(`   Low Issues: ${lowIssues}`);

        if (criticalIssues > 0) {
            console.log('\nüö® CRITICAL SECURITY ISSUES FOUND - IMMEDIATE ACTION REQUIRED');
        } else if (highIssues > 0) {
            console.log('\n‚ö†Ô∏è High severity security issues found - should be addressed soon');
        } else if (mediumIssues > 0) {
            console.log('\nüìã Medium severity security issues found - should be addressed');
        } else {
            console.log('\n‚úÖ No critical or high severity security issues found');
        }
    }
}

// CLI runner
if (require.main === module) {
    const scanner = new VulnerabilityScanner();

    scanner.runComprehensiveScan()
        .then(results => {
            const criticalIssues = results.filter(r => !r.passed && r.severity === 'critical').length;
            const highIssues = results.filter(r => !r.passed && r.severity === 'high').length;

            if (criticalIssues > 0) {
                process.exit(2); // Critical issues
            } else if (highIssues > 0) {
                process.exit(1); // High severity issues
            } else {
                process.exit(0); // No critical/high issues
            }
        })
        .catch(error => {
            console.error('Security scan failed:', error);
            process.exit(3);
        });
}